#!/usr/bin/env python
import sys
import os

def ConstructorArgumentList(Data):
    ret=""
    for d in Data:
        if d.has_key('Required'):
            ret+=" "+d['Type']+" "+d['Name']+"_"+DefaultArgumentValue(d)+","
    return ret[0:-1]

def ConstructorList(Data):
    ret=""
    for d in Data:
        if d.has_key('Required'):
            ret+=",\n        "+d['Name']+"(\""+d['Type']+"\", \""+d['Name']+"\", "+IsRequired(d)+", "+d['Name']+"_) "
    return ret

def DefaultValue(Data):
    if Data['Value']==None:
        return ""
    else:
        return ", "+Data['Value']

def DefaultArgumentValue(Data):
    if Data['Value']==None:
        return ""
    else:
        return " = "+Data['Value']

def IsRequired(Data):
    if Data['Required']:
        return "true"
    else:
        return "false"

def DefaultConstructorList(Data):
    ret=""
    for d in Data:
        if d.has_key('Required'):
            ret+=",\n        "+d['Name']+"(\""+d['Type']+"\", \""+d['Name']+"\", "+IsRequired(d)+DefaultValue(d)+") "
    return ret

def NeedsDefaultConstructor(Data):
    for d in Data:
        if d['Required']:
            return True
    return False

def Declaration(Data):
    if Data.has_key('Required'):
      return "    Property<"+Data['Type']+"> "+Data['Name']+";\n"
    else:
      return ""

def Copy(Data):
    if Data.has_key('Required'):
      return "        "+Data['Name']+" = other."+Data['Name']+";\n"
    else:
      return ""

def Register(Data):
    if Data.has_key('Required'):
      return "        properties_[\""+Data['Name']+"\"] = static_cast<PropertyElement*>(&"+Data['Name']+");\n" + "        propertiesOrdered_.push_back( static_cast<PropertyElement*>(&"+Data['Name']+") );\n"
    else:
      return ""

def Construct(Namespace, ClassName, Data):
    ret="""// This file was automatically generated. Do not edit this file!
#ifndef INITIALIZER_"""+Namespace+"_"+ClassName+"""_H
#define INITIALIZER_"""+Namespace+"_"+ClassName+"""_H

#include "exotica/Property.h"

namespace """ +Namespace+ """
{

class """+ClassName+" : public PropertyContainer"+"""
{
public:
    static std::string getContainerName() {return """+"\""+Namespace+"::"+ClassName+"\""+ """ ;}

    """
    if NeedsDefaultConstructor(Data):
        ret=ret+ClassName+"() : PropertyContainer(\""+Namespace+"::"+ClassName+"\")"+DefaultConstructorList(Data)+"""
    {
        RegisterParams();
    }

    """
    ret=ret+ClassName+"("+ConstructorArgumentList(Data)+") : PropertyContainer(\""+Namespace+"::"+ClassName+"\")"+ConstructorList(Data)+"""
    {
        RegisterParams();
    }

    void RegisterParams()
    {
"""
    for d in Data:
        ret+=Register(d)
    ret+="""    }

    void RegisterParams("""+ClassName+"""& other)
    {
"""
    for d in Data:
        ret+=Copy(d)
    ret+="""        RegisterParams();
    }

    void RegisterParams(const """+ClassName+"""& other)
    {
"""
    for d in Data:
        ret+=Copy(d)
    ret+="""        RegisterParams();
    }
"""
    for d in Data:
        ret+=Declaration(d)
    ret+="};\n}\n#endif"
    return ret

def ParseLine(line, ln, fn):
    last = line.find(";")
    if last>=0:
        line=line[0:last].strip()
    else:
        last = line.find("//")
        if last>=0:
            line = line[0:last].strip()
        else:
            line=line.strip()

    if len(line)==0:
        return None

    if line.startswith("#include"):
        return {'Include':line[8:].strip().strip(">").strip("<")}
    if line.startswith("#extends"):
        return {'Extends':line[8:].strip().strip(">").strip("<")}

    if last==-1:
        print "Can't find ';' in '"+fn+"', on line " + `ln`
        sys.exit(2)

    required = True
    if line.startswith("Required"):
        required = True
    elif line.startswith("Optional"):
        required = False
    else:
        print "Can't parse 'Required/Optional' tag in '"+fn+"', on line " + `ln`
        sys.exit(2)

    value = None
    type = ""
    name = ""
    if required==False:
        eq = line.find("=")
        if eq==-1:
            eq=last;
            value = "{}"
        else:
            value = line[eq+1:last]
        nameStart=line[0:eq].strip().rfind(" ")
        name = line[nameStart:eq].strip()
        type = line[9:nameStart].strip()
    else:
        nameStart=line[0:last].strip().rfind(" ")
        name = line[nameStart:last].strip()
        type = line[9:nameStart].strip()

    return {'Required':required, 'Type':type, 'Name':name, 'Value':value}

def ParseFile(filename):
    with open(filename) as f:
        lines = f.readlines()
    content = []
    i=0
    optionalOnly=False
    for l in lines:
        i=i+1
        Data=ParseLine(l,i,filename)
        if Data!=None:
            if Data.has_key('Required'):
              if Data['Required']==False:
                  optionalOnly=True
              else:
                  if optionalOnly:
                      print "Required properties have to come before Optional ones, in '"+filename+"', on line " + `i`
                      sys.exit(2)
            content.append(Data)
    return content

def Generate(Input, Output, Namespace, ClassName):
    print "Generating "+Output
    content = ParseFile(Input)
    txt=Construct(Namespace,ClassName,content)
    dir=os.path.dirname(Output)
    if not os.path.exists(dir):
        os.makedirs(dir)
    with open(Output,"w") as f:
        f.write(txt)

if __name__ == "__main__":
    if len(sys.argv)>2:
        n=(len(sys.argv)-2)/2
        for i in range(0,n):
            Generate(sys.argv[2+i],sys.argv[2+n+i],sys.argv[1],os.path.basename(sys.argv[2+i][0:-3])+"Initializer")
    else:
      print "Initializer generation failure: invalid arguments!"
      sys.exit(1)
